La clase `Maestro` decimos que es **abstracta** porque nunca vamos a tener maestros que no dominen un elemento particular, sólo existe para poder compartir código entre sus subclases, y es por ese motivo que no tenemos una forma para calcular el poder que tenga sentido definir en Maestro (lo correcto en este caso sería declarar `poder` como método abstracto en esta clase, para explicitar que las subclases deben proveer una definición).

Es importante entender que esto funciona como esperamos gracias al **method lookup**. Cuando se le mande `esGroso` a un maestro agua, buscará una implementación en su propia clase `MaestroAgua` y al no encontrarla seguirá buscando en `Maestro`. Si la implementación que encuentra allí tiene un llamado a `self.poder()`, no buscará la implementación desde `Maestro`, sino que empieza nuevamente desde la clase a partir de la cual ese maestro fue instanciado, o sea `MaestroAgua`.
